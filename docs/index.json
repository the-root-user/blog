[{"content":"In this post, we are going to learn what is a buffer overflow and will exploit it to get code execution.\n! Disable ASLR\nChecksec\nStack Smashing Take this C program:\n    program.c  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int helper(){ system(\u0026#34;/bin/sh\u0026#34;); // executes system shell } int overflow(){ char buffer[500]; // declaring buffer variable with specified size  int userinput; userinput = read(0, buffer, 700); // reading user input into buffer variable  printf(\u0026#34;\\nUser provided %d bytes. Buffer content is: %s\\n\u0026#34;, userinput, buffer); return 0; } int main(int argc, char *argv[]){ overflow(); return 0; }    The program reads user input\u0026hellip; .\nCompile it this way:     Terminal  gcc -m32 -fno-stack-protector -z execstack program.c -o program    Why those extra flags?  After compiling the code with gcc as:\ngcc code.c -o code or\nmake code make command is just another shortcut for us (for gcc)\n it does something.\nEIP Control Code Reuse gdb code # \u0026#39;code\u0026#39; is the name of our binary b main # instructing gdb to break at main function disassemble main # disassemble the main function Shellcode ","permalink":"https://the-root-user.github.io/blog/posts/pwn-0x1-buffer-overflow/","summary":"WTH is a buffer overflow? Let\u0026rsquo;s do it","title":"Pwn 0x1: Buffer Overflow"},{"content":"! We will not be diving deep into things but only as much as necessary. For further learning, I\u0026rsquo;ll link relevant resources.\n0.1 Prerequisites  Basic Computer Science knowledge Fundamental knowledge of C - here is a nice tutorial Curiosity - Consistency  Optional  Since, at first, we will be doing exploit development on Linux, it would be nice to learn the necessary things here. Some Assembly knowledge will benefit you a lot - here is a nice tutorial Gdb is going to play a key role in our exploit dev - here\u0026rsquo;s a lovely tutorial  0.2 Memory Structure High-level overview  More here  0.3 Architectures Comparison Here\u0026rsquo;s a C program:\n    program.c  #include \u0026lt;stdio.h\u0026gt; void print_user_data(char* arg1, char* arg2, char* arg3){ printf(\u0026#34;Here is Your data\\n\u0026#34;); printf(\u0026#34;Name: %s Age: %s Job: %s\\n\u0026#34;, arg1, arg2, arg3); } void main(int argc, char **argv){ if (argc!=4) { printf(\u0026#34;Please provide 3 inputs\\n\u0026#34;); } else { print_user_data(argv[1], argv[2], argv[3]); } }    The program takes some command line arguments from the user, checks if they are equivalent to 3 and then passes them to another function which prints some data on the console.\n After compiling the code with gcc as:     Terminal  gcc code.c -o code    or     Terminal  make code    make command is just another shortcut for us (for gcc)\n Here' what it does:     Terminal    Simple enough, right?\nWhen we execute a binary, the binary name and the arguments to its function(s) are stored on the stack (in memory). They are accessed differently in different architectures.\nAfter seeing the disassembled binaries of both archs, you will notice that the length of memory addresses changes. But.. wait\n How are the command line arguments being parsed in memory?\n Let\u0026rsquo;s compile the code, disassemble it, and see what\u0026rsquo;s happening under the curtains.\nx32 Compile the code with the command: gcc -m32 code.c -o code\nWhy -m32? When we're on a 64-bit OS, the -m32 flag tells the compiler (gcc) to compile the code and give us a 32-bit binary. If you are on 32-bit machine, you can skip it.  Disassembly You can just follow along with the tutorial, but if you\u0026rsquo;re curious how I disassembled the binary, here you go.\nThere are many a ways/tools to disassemble a binary. Here, I have used gdb in the following way:     Terminal  gdb code # \u0026#39;code\u0026#39; is the name of our binary b main # instructing gdb to break at main function disassemble main # disassemble the main function    \n    Terminal    In the case of 32-bit binary, we can see that first, the arguments are being pushed onto the stack and then the call to our function print_user_data is made. They are later popped off the stack before the program exits.\nx64 Compile the code with the command: gcc code.c -o code\nDisassembly     Terminal    On the other hand, in the case of 64-bit binary, arguments are first moved into registers and then our function print_user_data is called.\nNow that you understand the distinction between the two, it will come in handy later on, as we will be putting 32-bit binaries to test more frequently for simplicity.\n0.4 ELF The last thing to be aware of are the ELF files. Wondering what they are?\nELF files, short for Executable and Linkable Format, are standard executables for Linux and other Unix OSs (not exactly but, think of them as the EXE files on Windows).\nAnd as for our current program, since we compiled it on Linux, it also is an ELF file.     Terminal    We might discuss ELF files in detail later on. For further study, here\u0026rsquo;s a nice video.\n","permalink":"https://the-root-user.github.io/blog/posts/pwn-0x0-warmup/","summary":"Let\u0026rsquo;s get ready to Pwn","title":"Pwn 0x0: Warmup"}]